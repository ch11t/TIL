# 데이터 시각화

* 데이터

  * 피쳐의 개념

    > '특성'이나 '특징'이라는 의미
    >
    > '모델을 구성하는데 데이터가 가장 큰 영향을 줌'
    >
    > 모델은 함수 형태로 표현
    >
    > y = ax + b ( y : 종속 변수 / x : 독립 변수 / a,b : 알고리즘을 통해 최적값 찾음)

  * 데이터 테이블 (data table) : 데이터를 테이블(표)로 표현한 것

  * 데이터 인스턴스(data instance) : 하나의 데이터

    > 튜플(tuple) 이라고도 부름
    >
    > 엑셀에서의 한 줄  한 줄

  * 데이터의 분류 

    * 연속형 데이터 ( continuos data ) : 값이 끊어지지 않고 계속 연결되는 데이터로, 실수와 관련 된 값

      > 온도, 자동차의 속도
      >
      > 평균, 분산 등 통계적 기법 적용 가능

    * 이산형 데이터 ( discrete data ) : 연속적 값이 아니라 분리해서 표현하는 데이터로, 일종의 라벨로 구분 가능

      > 우편번호( 숫자로 표현 ), 성별 ( 텍스트로 표현 )
      >
      > 텍스트 형태의 값도 숫자 형태로 바꾸어 수식의 입력에 할당

    * 이 둘의 가장 큰 차이는 그 숫자의 의미가 스케일(scale)이 있는가 없는가 이다.

  * 이산형 데이터의 분류

    * 숫자형 데이터 ( numeri data ) : 연속형 데이터.

      > 정량적으로 측정 가능한 데이터 타입을 의미
      >
      > 정수나 실수 값
      >
      > 단위가 있으면 등간척도형(interval-scaled type)
      >
      > 데이터와 비율이 있으면 비율척도형(ratio-scaled type) 데이터

    * 명목형 데이터(nominal data) : 카테고리로 분류 가능한 데이터 타입.

      > 이산형 데이터의 일종이며 '명목척도' 라고도 표현
      >
      > 두 개의 카테고리로만 데이터가 분류된다면 이진형 데이터 타입

    * 서수형 타입(ordinal data) : 범주형 데이터의 일종이지만 데이터 간의 순서가 존재하는 데이터 타입

      > 음료수 병의 크기를 대/중/소로 나누는 것

  * 데이터의 형식

    > 데이터를 호출하기 위해서는 데이터 테이블 형태로 저장될 수 있는 타입 사용
    >
    > 다양한 데이터 타입으로 데이터 테이블을 저장할 수 있음
    >
    > 대표적으로 'csv(comma separate value)' 또는 'xlsx' 파일
    >
    > 트리 형태로 저장되어 있는 'json'이나 'xml'
    >
    > 파이썬에 특화된 데이터 저장 형태인 'pickle'
    >
    > 큰 데이터를 저장하는 이진 데이터 형식인 'h5'

* Numpy

  > `기계 학습에서는 파이썬의 기본 리스트로 충분하지 않음
  >
  > `데이터를 처리할 때는 리스트와 리스트 간의 연산이 가능해야 하는데 기본 리스트는 이를 지원하지 않음
  >
  > `연산 속도도 중요하기 때문에 데이터 과학자들은 기본 리스트 대신에 넘파이(Numpy)를 선호

  * 개념

    > 파이썬의 고성능 과학 계산용 라이브러리
    >
    > 벡터나 행렬 같은 선형대수의 표현법을 코드로 처리
    >
    > 사실상의 표준 라이브러리
    >
    > 다차원 리스트나 크기가 큰 데이터 처리에 유리

  * 특징

    > 과학적인 계산을 위해서 만들어진 형태
    >
    > 정적 할당의 구성 방식으로 사용하기 위하여 만들어짐
    >
    > 행렬 연산 특화
    >
    > 일반 List에 비해 빠르고, 메모리를 효율적으로 사용
    >
    > 속도가 빠르고 메모리 사용이 효율적
    >
    > 데이터를 메모리에 할당하는 방식이 기존과 다름
    >
    > 반복문을 사용하지 않음
    >
    > 연산할 때 병렬로 처리
    >
    > 함수를 한 번에 많은 요소에 적용
    >
    > 반복문 없이 데이터 배열에 대한 처리를 지원하여 빠르고 편리
    >
    > 선형대수와 관련된 다양한 기능을 제공
    >
    > C, C++, 포트란 등의 언어와 통합이 가능

  * 성능

    * 넘파이의 텐서 연산의 장점

      > C와 유사한 형태로 메모리를 관리하면서 C와 같은 연산 속도로 계산할 수 있음
      >
      > 메모리 구조상 요소들이 붙어있기 때문
      >
      > 파이썬의 가장 큰 특징인 동적 타이핑을 포기했지만, C로 구현되어 있어 배열 연산에 있어 매우 큰 성능적 우위 확보
      >
      > 대용량 배열 연산에서 넘파이가 사실상 표준으로 사용됨

    * 단점

      > 연결 연산처럼 여러 배열을 붙이는 연산에서는 일반적인 리스트에 비해 느림
      >
      > 필요할 때 마다 메모리 탐색 과정으로 새로운 공간을 잡아야 하기 때문

  * 넘파이 배열(ndarray) : 넘파이에서 텐서 데이터를 다루는 객체

  * 텐서(tensor) : 선형대수의 데이터 배열

    > 랭크(rank)에 따라 이름이 다름

  * 배열 생성

    > np.array 함수 사용하여 배열 생성
    >
    > `np.array([1,2,4,5],float)`
    >
    > ​	매개변수 1 : 배열정보
    >
    > ​	매개변수 2 : 넘파이 배열로 표현하려는 데이터 타입
    >
    > Numpy 형식으로 배열의 원소를 입력할 때는 반드시 리스트 형식으로 입력

  * 파이썬 리스트와 넘파이 배열의 차이점

    > 텐서 구조에 따라 배열 생성
    >
    > ​	` 배열의 모든 구성 요소에 값이 존재해야 함
    >
    > 동적 타이핑을 지원하지 않음
    >
    > ​	` 하나의 데이터 타입만 사용
    >
    > 데이터를 메모리에 연속적으로 나열
    >
    > ​	` 각 값 메모리 크기가 동일
    >
    > ​	` 검색이나 연산 속도가 리스트에 비해 훨씬 빠름

  * 데이터 특징을 출력하는 요소(property)는 dtype과 shape

    > dtype은 넘파이 배열의 데이터 타입을 반환
    >
    > shape는 넘파이 배열에서 객체(object)의 차원(dimension)에 대한 구성 정보를 반환
    >
    > 최대자원 np.ndim
    >
    > 원소개수 np.size

  * 매개변수 dtype으로 넘파이 배열의 데이터 타입 지정

    > 변수가 사용하는 메모리 크기가 정해짐
    >
    > dtype을 실수형인 float으로 지정한다면 모든 데이터가 실수형으로 저장
    >
    > itemsize 요소 (property)로 넘파이 배열에서 각 요소가 차지하는 바이트(byte) 확인
    >
    > ​	` np.float64로 dtype을 선언하면 64비트, 즉 8바이트 차지
    >
    > ​	` np.float32로 dtype을 선언하면 32비트, 즉 4바이트 차지

  * reshape

    > 배열을 원하는 모양으로 생성 및 변형
    >
    > ```python
    > x = np.array([[1,2,4,5],[1,3,5,8]])
    > x.reshape(-1,)
    > ```
    >
    > 반드시 전체 요소의 개수는 통일
    >
    > ```python
    > x=np.array([0,1,2,3,4,5,6,7])
    > x.reshape(2,2)(X)
    > ```
    >
    > -1을 사용하면 나머지 차원의 크기를 지정했을 때 전체 요소의 개수를 고려하여 마지막 차원이 자동으로 지정됨

  * flatten 함수는 데이터 그대로 1차원으로 변경

    > 데이터의 개수는 그대로 존재
    >
    > 배열의 구조만 변한다
    >
    > ```python
    > x=np.array([0,1,2,3,4,5,6,7])
    > x.reshape(2,2,2)
    > x.flatten()
    > ```

  * 인덱싱(indexing)

    > 리스트에 있는 값의 상대적인 주소(offset)로 값에 접근
    >
    > 넘파이 배열의 인덱스 표현에는 ',' 을 지원
    >
    > ​	`[행]` `[열]` 또는 `[행,열]` 형태
    >
    > 3차원 텐서 이상은 shape에서 출력되는 랭크 순서대로 인덱싱에 접근

  * 슬라이싱(slicing)

    > 인덱스를 사용하여 리스트 일부를 잘라내어 반환
    >
    > 넘파이 배열은 행과 열을 나눠 슬라이싱 가능
    >
    > 증가값(step) : 리스트에서 데이터의 요소를 호출 할 때 데이터를 건너뛰면서 반환
    >
    > ​	` '[시작 인덱스 : 마지막 인덱스 : 증가값]` 형태
    >
    > ​	각 랭크에 있는 요소별로 모두 적용할 수 있음

  * arange

    > range 함수와 같이 차례대로 값을 생성
    >
    > '(시작 인덱스, 마지막 인덱스, 증가값)' 으로 구성
    >
    > range 함수와 달리 증가값에 실수형이 입력되어도 값을 생성할 수 있음
    >
    > 소수점 값을 주기적으로 생성할 때 유용

  * ones 함수

    > 1로만 구성된 넘파이 배열을 생성
    >
    > 사전에 shape 값을 넣어서 원하는 크기의 넘파이 배열 생성

  * zeros 함수

    > 0 으로만 구성된 넘파이 배열을 생성

  * empty 함수

    > 활용 가능한 메모리 공간 확보하여 반환
    >
    > ones와 zeros는 먼저 shape의 크기만큼 메모리를 할당하고 그곳에 값을 채움
    >
    > 해당 메모리 공간에 값이 남았을 경우 그 값을 함께 반환
    >
    > empty는 메모리 초기화 않아 생성될 때 마다 다른 값 반환

  * 생성 지점에서 dtype을 지정해주면 해당 데이터 타입으로 배열 생성

  * ones_like 함수

    > 기존 넘파이 배열과 같은 크기로 만들어 내용을 1로 채움

  * zeros_like 함수

    > 기존 넘파이 배열과 같은 크기로 만들어 내용을 0으로 채움

  * empty_like 함수

    > 기존 넘파이 배열과 같은 크기로 만들어 빈 상태로 만듦

  * identity 함수

    > 단위행렬(i행렬)을 생성
    >
    > 매개변수 n으로 nxn 단위행렬을 생성

  * eye 함수

    > 시작점과 행렬 크기를 지정, 단위 행렬 생성
    >
    > N은 행의 개수, M은 열의 개수를 지정
    >
    > k는 열의 값을 기준으로 시작 인덱스

  * diag 함수

    > 행렬의 대각성분 값을 추출

  * uniform 함수 : 균등분포 함수

    > 'np.random.uniform(시작값, 끝값, 데이터개수)'

  * normal 함수 : 정규분포 함수

    > 'np.random.normal(평균값, 분산, 데이터개수)'

  * 연산 함수(operation function)

    > 배열 내부 연산을 지원하는 함수

  * 축(axis)

    > 배열의 랭크가 증가할 때마다 새로운 축이 추가되어 차원 증가

  * sum 함수

    > 각 요소의 합을 반환
    >
    > sum 함수를 랭크가 2 이상인 배열에 적용할 때 축으로 연산의 방향을 설정

  * 연결 함수 (concatenation functions)

    > 두 객체 간의 결합을 지원하는 함수

  * vstack 함수

    > 배열을 수직으로 붙여 하나의 행렬을 생성

  * hstack 함수

    > 배열을 수평으로 붙여 하나의 행렬을 생성

  * concatenate 함수

    > 축을 고려하여 두 개의 배열을 결합
    >
    > 스택(stack) 계열의 함수와 달리 생성될 배열과 소스가 되는 배열의 차원이 같아야 함
    >
    > 두 벡터를 결합하고 싶다면, 해당 벡터를 일단 2차원 배열 꼴로 변환 후 행렬로 나타내야 함

  * 사칙연산 함수

    > 넘파이는 파이썬과 동일하게 배열 간 사칙연산 지원
    >
    > ​	` 행렬과 행렬, 벡터와 벡터 간 사칙연산이 가능
    >
    > 같은 배열의 구조일 때 요소별 연산 ( element-wise operation )
    >
    > ​	`요소별 연산 : 두 배열의 구조가 동일할 경우 같은 인덱스 요소들끼리 연산

  * 배열 간의 곱셈에서는 요소별 연산과 벡터의 내적(dot product) 연산 가능

    > 벡터의 내적 : 두 배열 간의 곱셈
    >
    > 두 개의 행렬에서 첫 번째 행렬의 열 크기와 두 번째 행렬의 행 크기가 동일해야 함
    >
    > mxn 행렬과 nxl 행렬, 벡터의 내적 연산하면 mxl의 행렬 생성

  * dot 함수

    > 벡터의 내적 연산

  * 브로드 캐스팅 연산 (broadcating operations)

    > 하나의 행렬과 스칼라 값들 간의 연산이나 행렬과 벡터간의 연산
    >
    > ​	` 방송국의 전파가 퍼지듯 뒤에 있는 스칼라 값이 모든 요소에 퍼지듯이 연산

  * 비교 연산

    > 연산 결과는 항상 불린형(boolean type)을 가진 배열로 추출
    >
    > 브로드캐스팅 비교 연산
    >
    > ​	` 하나의 스칼라 값과 벡터 간의 비교 연산은 벡터 내 전체 요소에 적용
    >
    > 요소별 비교 연산
    >
    > ​	` 두 개의 배열 간 배열의 구조가 동일한 경우
    >
    > ​	` 같은 위치에 있는 요소들끼리 비교 연산
    >
    > ​	` [1 > 2, 3 > 1, 0 > 7] 과 같이 연산이 실시된 후 이를 반환

  * all 함수

    > 배열 내부의 모든 값이 참일 때는 True
    >
    > 하나라도 참이 아닐 경우에는 False 를 반환
    >
    > and 조건을 전체 요소에 적용

  * any 함수

    > 배열 내부의 값 중 하나라도 참일 때는 True
    >
    > 모두 거짓일 경우 False를 반환
    >
    >  or 조건을 전체 요소에 적용

  * where 함수

    > 배열이 불린형으로 이루어졌을 때 참인 값을의 인덱스를 반환

  * argsort

    > 배열 내 값들을 작은 순서대로 인덱스를 반환

  * argmax

    > 배열 내 값들 중 가장 큰 값의 인덱스를 반환

  * argmin

    > 배열 내 값들 중 가장 작은 값의 인덱스를 반환

  * 불린 인덱스

    > 배열에 있는 값들을 반환할 특정 조건을 불린형의 배열에 넣어서 추출
    >
    > 인덱스에 들어가는 배열은 불린형이어야 함
    >
    > 불린형 배열과 추출 대상이 되는 배열의 구조가 같아야 함

  * 팬시 인덱스

    > 정수형 배열의 값을 사용하여 해당 정수의 인덱스에 위치한 값을 반환
    >
    > 인덱스 항목에 넣을 배열은 정수로만 구성되어야함
    >
    > 정수값의 범위는 대상이 되는 배열이 가지는 인덱스의 범위 내 대상이 되는 배열과 인덱스 배열의 구조가 같을 필요는 없음