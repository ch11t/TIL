# 알고리즘 특강 1일차





# 2.문제

두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.

입력 첫째 줄에 A, 둘째 줄에 B가 주어진다. (0 < A, B < 10)

출력 첫째 줄에 A+B를 출력한다.

In [*]:

```
a=int(input())
b=int(input())
print(a+b)
```

# 3.문제

두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.

입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)

출력 각 테스트 케이스마다 A+B를 출력한다.

In [*]:

```
T=int(input())
for _ in range(T):
    a, b = map(int,input().split())
    print(a+b)

```

# 4.문제

두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.

입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. A와 B는 콤마(,)로 구분되어 있다. (0 < A, B < 10)

출력 각 테스트 케이스마다 A+B를 출력한다.

In [ ]:

```
T=int(input())
for _ in range(T):
    a, b = map(int,input().split(','))
    print(a+b)

```

# 5.문제

두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.

입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)

출력 각 테스트 케이스마다 "Case #x: "를 출력한 다음, A+B를 출력한다. 테스트 케이스 번호는 1부터 시작한다.

In [ ]:

```
T=int(input())
for i in range(T):
    a, b = map(int,input().split())
    print(f"Case #{i+1}: {a+b}")
```

# 6. 문제

두 정수 A와 B를 입력받은 다음, A+B를 출력하는 프로그램을 작성하시오.

입력 첫째 줄에 테스트 케이스의 개수 T가 주어진다.

각 테스트 케이스는 한 줄로 이루어져 있으며, 각 줄에 A와 B가 주어진다. (0 < A, B < 10)

출력 각 테스트 케이스마다 "Case #x: A + B = C" 형식으로 출력한다. x는 테스트 케이스 번호이고 1부터 시작하며, C는 A+B이다.

In [ ]:

```
T=int(input())
for i in range(T):
    a, b = map(int,input().split())
    print(f"Case #{i+1}: {a} + {b} = {a+b}")
```

# 7. 문제

첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제

입력 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.

출력 첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

In [ ]:

```
T=int(input())
for i in range(T):
    print('*'*(i+1))

```

# 8. 문제

첫째 줄에는 별 1개, 둘째 줄에는 별 2개, N번째 줄에는 별 N개를 찍는 문제

하지만, 오른쪽을 기준으로 정렬한 별(예제 참고)을 출력하시오.

입력 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.

출력 첫째 줄부터 N번째 줄까지 차례대로 별을 출력한다.

In [ ]:

```
T=int(input())
for i in range(T):
    print(" " * (T - (i+1)) + '*' * (i + 1))
```

# 9.문제

예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.

입력 첫째 줄에 N(1 ≤ N ≤ 100)이 주어진다.

출력 첫째 줄부터 차례대로 별을 출력한다.

예제 입력 1 1

예제 출력 1 *

예제 입력 2 2

예제 출력 2

- *
  - *

In [ ]:

```
N=int(input())

for i in range(N):
    if i%2!=0:
        print((' '+'*')*N)
    else:
        print(('*'+' ')*N)

```

# 10.문제

알파벳 소문자로만 이루어진 단어가 주어진다. 이때, 이 단어가 팰린드롬인지 아닌지 확인하는 프로그램을 작성하시오.

팰린드롬이란 앞으로 읽을 때와 거꾸로 읽을 때 똑같은 단어를 말한다.

level, noon은 팰린드롬이고, baekjoon, online, judge는 팰린드롬이 아니다.

입력 첫째 줄에 단어가 주어진다. 단어의 길이는 1보다 크거나 같고, 100보다 작거나 같으며, 알파벳 소문자로만 이루어져 있다.

출력 첫째 줄에 팰린드롬이면 1, 아니면 0을 출력한다.

In [ ]:

```
N=input()

if N[::1] == N[::-1]:
    print(1)
else:
    print(0)

```

# 11.문제

고창영은 맨날 오타를 낸다. 창영이가 오타를 낸 문장과 오타를 낸 위치가 주어졌을 때, 오타를 지운 문자열을 출력하는 프로그램을 작성하시오.

창영이는 오타를 반드시 1개만 낸다.

입력 첫째 줄에 테스트 케이스의 개수 T(1<=T<=1,000)가 주어진다. 각 테스트 케이스는 한 줄로 구성되어 있다. 첫 숫자는 창영이가 오타를 낸 위치이고, 두 번째 문자열은 창영이가 친 문자열이다. 문자열의 가장 첫 문자는 1번째 문자이고, 문자열의 길이는 80을 넘지 않고, 대문자로만 이루어져 있다. 오타를 낸 위치는 문자열 길이보다 작거나 같다.

출력 각 테스트 케이스에 대해 오타를 지운 문자열을 출력한다.

In [ ]:

```
T=int(input())

for _ in range(T):
    Num,Str = input().split()
    print(Str[:int(Num)-1]+Str[int(Num):])

```

# 12.문제

아주 멀리 떨어져 있는 작은 나라가 있다. 이 나라에서 가장 공부를 잘하는 학생들은 모두 다른 나라로 유학을 간다. 정부는 최고의 학생들이 자꾸 유학을 가는 이유를 찾으려고 했다. 하지만, 학생들의 이유가 모두 달랐기 때문에 정확한 이유를 찾을 수 없었다. 정부의 고위직은 뛰어난 학생들이 자꾸 유학을 가는 현상을 매우 불쾌해 했다.

가장 많은 학생들이 유학을 가는 대학교는 영국의 캠브리지 대학교이다. 정부는 인터넷 검열을 통해서 해외로 나가는 이메일의 내용 중 일부를 삭제하기로 했다. 이메일의 각 단어 중에서 CAMBRIDGE에 포함된 알파벳은 모두 지우기로 했다. 즉, 어떤 이메일에 LOVA란 단어가 있다면, A는 CAMBRIDGE에 포함된 알파벳이기 때문에, 받아보는 사람은 LOV로 받는다.

이렇게, 어떤 단어가 주어졌을 때, 검열을 거친 후에는 어떤 단어가 되는지 구하는 프로그램을 작성하시오.

입력 첫째 줄에 알파벳 대문자로 이루어진 단어가 주어진다. 이 단어는 적어도 3글자이며, 많아야 100글자이다.

출력 입력으로 주어진 단어를 정부가 검열을 하면 어떻게 변하는지를 출력한다. 즉, 단어에서 CAMBRIDGE에 포함된 알파벳을 모두 지운 뒤 출력한다. 항상 정답의 길이는 0보다 크다.

In [*]:

```
N=input()
Del="CAMBRIDGE"

for i in Del:
    N=N.replace(i,"")
    
print(M)

'''
# 다른 방법

for i in input():
    if not i in "CAMBRIDGE":
        print(end=i)

'''
```

# 13.문제

태보(TaeBo)란, 태권도와 복싱을 조합한 운동이다. 복싱의 공격 기술로는 민첩하게 앞주먹을 뻗으면서 가볍게 치는 잽, 옆으로 치는 펀치인 훅이 있다.

선풍적인 인기에 태보 강의를 들으며 태보를 마스터한 혜정이는 이제 펀치 속도가 워낙 빨라서 잽과 훅을 반복하다보면 잔상이 남는다.

얼굴의 왼편에 왼손의 잔상이, 오른편에는 오른손이 잔상이 남을 때 혜정이는 주먹을 몇 번 뻗었을까?

주먹의 잔상은 =로 시작하여 @로 끝나고, 잔상이 남지 않는 경우는 없다. 얼굴 형태가 (^0^) 꼴이고, 주먹의 잔상이 같은 곳에 위치하지 않는다.

입력 문자열의 길이는 1,000을 넘지 않는다.

출력 첫째 줄에 왼손의 잔상의 수와 오른손의 잔상의 수를 출력한다.

In [ ]:

```
left, right = input().split("0")
print(left.count("@"), right.count("@"))
```